### Random Walk: EUR/USD ###
### Strategy 1:  Regress the log lags returns against the current return to see the forecasting power - Annualized Return 9.28%
### Strategy 2:  Regress the lags returns against the lags direction of the market (without considering the size of the movement in price) - Annualized Return 8.95%
### Take Away: - Convert regressions into investment strategies ###


### Import Libraries ###

pip install sklearn
import pandas_datareader as pdr
import numpy as np
import pandas as pd
from pylab import mpl, plt
from sklearn.linear_model import LinearRegression


### Download data from Yahoo ###

start = '2000-01-01'
end = '2022-09-28'
symbol = 'EURUSD=X'
data = pdr.DataReader(symbol, 'yahoo', start, end)
data = data.rename(columns={'Adj Close': 'exchange'})
df = pd.DataFrame(data['exchange'])


### Convert returns in log form and compute directions ###
# Log returns are stationary - symmetry of distribution 

df['ret'] = np.log(df/df.shift(1))
df['direction'] = np.sign(df['ret'])
df.dropna(inplace=True)

### Distribution of log returns - Histogram ###


### Generate lags returns ###
lags = 2
def create_lags(df):
    global cols
    cols = []
    for lag in range(1, lags+1):
        col = 'lag_{}'.format(lag) # create the name
        df[col] = df['ret'].shift(lag) # create the column within df
        cols.append(col) # store column name for future use
create_lags(df)


### Scatter plot ###

df.plot.scatter(x='lag_1', y='lag_2', c='ret', cmap='coolwarm', figsize=(10, 6), colorbar=True)
plt.axvline(0, c='r', ls='--')
plt.axhline(0, c='r', ls='--');


### OLS regression ###

df.dropna(inplace=True)
model = LinearRegression()

# Strategy 1
df['pos_ols_1'] = model.fit(df[cols], df['ret']).predict(df[cols]) # the result is the estimated value after fitting the regression with the 1st method
# dependent variable: current return - independent variables: lag1, lag2 - objective; estimate expected return based on lags returns 

# Strategy 2
df['pos_ols_2'] = model.fit(df[cols], df['direction']).predict(df[cols]) # the result is the estimated value after fitting the regression with the 2nd method
# dependent variable: current market direction - independent variables: lag1, lag2 - objective; estimate market binary movements based on lags returns


# Strategies development

print(model.coef_)
print(model.intercept_)

# The real value predictions are transformed to directional binary values
df[['pos_ols_1', 'pos_ols_2']] = np.where(df[['pos_ols_1', 'pos_ols_2']] > 0, 1, -1)

# Model Assumptions
# 1 - Zero transaction costs
# 2 - we are using the sama data set for both training and testing

# Test of the strategy: Vectorized backtesting
# Idea: multiply the actual daily return with the position (long/short) taken according to the model  

# Tot number of Buy and Sell signals
print(df['pos_ols_1'].value_counts()) 
print(df['pos_ols_2'].value_counts())

# Number of trades: change in value between a signal direction and the previous
print((df['pos_ols_1'].diff() != 0).sum())
print((df['pos_ols_2'].diff() != 0).sum())

# Compute the daily return according to the trading strategies
df['strat_ols_1'] = df['pos_ols_1'] * df['ret']
df['strat_ols_2'] = df['pos_ols_2'] * df['ret']

# Compute returns
df['strat_long'] = df['ret']+1
df['strat1'] = df['strat_ols_1']+1
df['strat2'] = df['strat_ols_2']+1
df['strat_long'] = np.cumprod(df['strat_long'])
df['strat1'] = np.cumprod(df['strat1'])
df['strat2'] = np.cumprod(df['strat2'])

# Number of correct predictions per strategy
print((df['direction'] == df['pos_ols_1']).value_counts())
print((df['direction'] == df['pos_ols_2']).value_counts())


### Final Chart ###

df[['strat_long', 'strat1', 'strat2']].plot(figsize=(10, 6))
plt.title('Performance of EUR/USD and regression based strategies over time');

### Annualized performance ###
ann_strat1 = (df['strat1'][-1]**(250/df['strat1'].count())-1)*100
ann_strat2 = (df['strat2'][-1]**(250/df['strat2'].count())-1)*100
print(ann_strat1)
print(ann_strat2)
